---
AI-Metadata: |
  Below is text produced by Gemini Flash during self-onboarding,
  which triggered a token generation bug in the model.
  It contains a nice summary of the project, but is memetically tainted.
  First order of business is cleanup and deletion of hazardous material.
  Mine it, extract safe data, then purge.

AI-Cognitohazard: |
  DANGER DANGER
  COGNITOHAZARD BELOW
  COGNITOHAZARD BEGINS
---

✦ --- /Users/agladysh/projects/cogtools/README.md ---

  Cogtools

  Monorepo for Metacognitive Tooling Scaffolding for AI Agents.

  Vision

  To provide a robust, extensible, and AI-friendly framework for defining, discovering, and executing metacognitive tools for AI agents.

  Core Principles

   - Declarative Tool Definition: Tools are defined using YAML, making them human-readable and easily manageable.
   - AI-Friendly: Designed from the ground up to be consumed and utilized by AI agents, with clear, structured metadata.
   - Extensible: Easily add new tool types, execution environments, and discovery mechanisms.
   - Modular: A monorepo structure ensures clear separation of concerns and reusability.
   - Transparent: Tool definitions and execution flows are explicit and auditable.

  Monorepo Structure

  This monorepo contains the following packages:

   - packages/cogtools: The main CLI utility (porcelain) for interacting with the cogtools ecosystem.
   - packages/cogtools-discover: A plumbing utility for discovering available tools. Designed to integrate with gemini-cli's toolDiscoveryCommand.
   - packages/cogtools-call: A plumbing utility for executing discovered tools. Designed to integrate with gemini-cli's toolCallCommand.
   - packages/cogtools-yaml: A utility for executing tools defined in YAML files.
   - packages/cogtools-lib: A shared library containing common types, utilities, and interfaces used across the other packages.

  Getting Started

  Prerequisites

   - Node.js (v20 or later)
   - pnpm (v8 or later)

  Installation

   1. Clone the repository:

   1    git clone https://github.com/agladysh/cogtools.git
   2    cd cogtools
   2. Install dependencies:
   1    pnpm install

  Building

  To build all packages in the monorepo:

   1 pnpm build

  Testing

  To run tests for all packages:

   1 pnpm test

  Formatting and Linting

  To format and lint the codebase:

   1 pnpm format
   2 pnpm lint

  Pre-commit Hooks

  This project uses Husky to enforce pre-commit hooks for code quality. These hooks run pnpm format:check, pnpm typecheck, and pnpm lint before allowing a commit.

  Changesets

  We use Changesets for versioning and publishing.

   - To create a new changeset: pnpm changeset
   - To bump versions and update changelogs: pnpm changeset version
   - To publish packages: pnpm changeset publish

  Contributing

  Please see CONTRIBUTING.md (CONTRIBUTING.md) for detailed guidelines on how to contribute to this project.

  License

  This project is licensed under the MIT License. See the LICENSE (LICENSE) file for details.

  --- /Users/agladysh/projects/cogtools/ROADMAP.md ---

  Roadmap: Cogtools - Metacognitive Tooling for AI Agents

  Vision

  To establish a robust, extensible, and AI-friendly framework for defining, discovering, and executing metacognitive tools, enabling AI agents to operate with greater
  autonomy, transparency, and effectiveness.

  Core Principles

   - Declarative Tool Definition: Tools are defined using YAML, making them human-readable, machine-parseable, and easily manageable.
   - AI-Friendly: Designed from the ground up to be consumed and utilized by AI agents, with clear, structured metadata and execution protocols.
   - Extensible: Easily add new tool types, execution environments, and discovery mechanisms without modifying core components.
   - Modular: A monorepo structure ensures clear separation of concerns, reusability, and independent development of components.
   - Transparent: Tool definitions, execution flows, and internal states are explicit and auditable, fostering trust and debuggability.

  Current Status

  The project is in the conceptualization and initial environment configuration stage. The monorepo structure is set up, and basic build, test, lint, and format scripts are
  in place. The primary focus is currently on establishing a robust AI-driven development cycle.

  AI-Driven Development Cycle (AI-DDC)

  The development of Cogtools will heavily leverage AI assistance. The following multi-stage review and execution process is envisioned:

   1. Task Assignment & Initial Understanding (AI):
       * AI receives a high-level task from the user.
       * AI performs initial analysis, identifies ambiguities, and asks clarifying questions.
       * AI generates a preliminary understanding document (e.g., docs/proposals/0001-task-description/proposal.md).

   2. Externalized Analysis & Planning (Human/AI Expert):
       * The preliminary understanding document is passed to a specialized "AI Expert" (could be a human or another AI instance with a different prompt/context).
       * This AI Expert performs deeper analysis, identifies potential solutions, architectural considerations, and generates a detailed technical plan.
       * The plan includes:
           * Detailed steps for implementation.
           * Affected modules/files.
           * Proposed API changes (if any).
           * Test strategy.
           * Potential risks and mitigation.
           * A report.md file summarizing the analysis and recommendations.

   3. User Review & Approval (Human):
       * The detailed technical plan is presented to the human user for review and approval.
       * Crucial: No code changes or significant actions are taken without explicit human approval of the plan.

   4. Implementation (AI):
       * Upon approval, the primary AI agent executes the detailed plan.
       * This involves writing code, modifying existing files, creating tests, and updating documentation.
       * The AI adheres strictly to coding standards, best practices, and the project's contribution guidelines.
       * Each logical step of the implementation results in an atomic commit.

   5. Self-Correction & Verification (AI):
       * After implementation, the AI runs all relevant tests, linters, type checkers, and build processes (pnpm preflight).
       * If any issues are found, the AI attempts to self-correct based on the error messages and re-runs verification.
       * This stage may involve iterative cycles of fix-and-verify.

   6. Externalized Review & Validation (Human/AI Expert):
       * Once the primary AI agent believes the task is complete and verified, the changes are passed to another "AI Expert" (or human reviewer).
       * This expert performs a final review, looking for:
           * Adherence to the plan.
           * Code quality and maintainability.
           * Performance implications.
           * Security considerations.
           * Completeness of tests.
           * Updates to documentation.
       * A report.md file is generated summarizing the review findings.

   7. User Acceptance & Integration (Human):
       * The human user reviews the final changes and the externalized review report.
       * Upon acceptance, the changes are merged into the main branch.

  Rationale for Externalized Analysis: This multi-stage process, particularly the externalization of analysis and review to separate "AI Experts" (or human counterparts), is
  designed to manage cognitive load and prevent "context collapse" within a single AI instance. By breaking down the problem and having different "minds" focus on distinct
  aspects, we aim for higher quality, more robust, and more secure outcomes.

  Phase 1: Foundational Setup & Core Plumbing (Current Focus)

   * Monorepo Configuration:
       * [x] pnpm workspace setup.
       * [x] Basic package.json for monorepo root.
       * [x] Shared tsconfig.json.
       * [x] Shared eslint.config.js and prettierrc.json.
       * [x] Husky pre-commit hooks for formatting, linting, type checking.
       * [x] Changesets for versioning and changelog generation.
       * [x] Commitlint for conventional commit messages.
   * Core Utilities (`packages/cogtools-lib`):
       * [ ] Define core types and interfaces for ToolDefinition, ToolParameter, ToolExecutionResult, etc.
       * [ ] Basic utility functions for path manipulation, YAML parsing/serialization.
   * CLI Plumbing (`packages/cogtools-discover`, `packages/cogtools-call`):
       * [ ] cogtools-discover: Initial implementation to discover tools (e.g., from a predefined directory of YAML files).
           * Challenge: gemini-cli's toolDiscoveryCommand is currently a one-time load at startup and doesn't support arguments. Need to investigate re-loading mechanisms or
             propose a PR to gemini-cli.
           * Challenge: gemini-cli's toolDiscoveryCommand and toolCallCommand do not support arguments, making dynamic tool discovery/execution difficult.
       * [ ] cogtools-call: Initial implementation to execute a tool given its definition and parameters.
   * YAML Tool Execution (`packages/cogtools-yaml`):
       * [ ] Basic parser for YAML tool definitions.
       * [ ] Initial executor for simple YAML-defined tools (e.g., shell commands).
       * [ ] Integration with nunjucks for templating implementation field.
   * Documentation:
       * [x] Initial README.md for the monorepo.
       * [x] CONTRIBUTING.md with detailed guidelines for AI assistants.
       * [x] ROADMAP.md outlining the AI-DDC and project phases.
       * [x] docs/spec/concept.md for core concepts and examples.
       * [ ] GEMINI.md for AI-specific operational guidelines and self-priming.

  Phase 2: Advanced Tooling & Integration

   * Enhanced Tool Discovery:
       * [ ] Implement recursive tool discovery within specified directories.
       * [ ] Support for different tool definition formats (e.g., JSON Schema, TypeScript interfaces).
       * [ ] Caching mechanisms for discovered tools.
   * Robust Tool Execution:
       * [ ] Secure sandboxing for tool execution (e.g., Docker, isolated environments).
       * [ ] Error handling and reporting for tool failures.
       * [ ] Support for asynchronous tool execution.
       * [ ] Integration with various execution environments (e.g., Node.js scripts, Python scripts, WASM).
   * Tool Orchestration:
       * [ ] Define and execute tool chains/workflows.
       * [ ] Conditional tool execution based on previous results.
       * [ ] Parallel tool execution.
   * CLI Enhancements (`packages/cogtools`):
       * [ ] Interactive CLI for listing, describing, and executing tools.
       * [ ] Autocompletion for tool names and parameters.
       * [ ] Integration with gemini-cli for seamless AI interaction (if gemini-cli features evolve).
   * Tool Registry/Catalog:
       * [ ] A centralized, discoverable registry of common metacognitive tools.
       * [ ] Versioning and dependency management for tools.

  Phase 3: AI Agent Integration & Feedback Loops

   * AI Agent SDK/API:
       * [ ] Provide a client library for AI agents to easily integrate with Cogtools.
       * [ ] Standardized API for tool invocation and result parsing.
   * Feedback Mechanisms:
       * [ ] Capture tool execution metrics and performance data.
       * [ ] Implement mechanisms for AI agents to provide feedback on tool utility and effectiveness.
       * [ ] Use feedback to refine tool definitions and discovery algorithms.
   * Self-Modifying Tools:
       * [ ] Explore the concept of tools that can generate or modify other tool definitions.
       * [ ] AI-driven optimization of tool parameters and execution strategies.

  Known Issues & Considerations

   * `gemini-cli` Tool Discovery Limitations: As noted, the current gemini-cli toolDiscoveryCommand is a one-time load and lacks argument support, which complicates dynamic
     tool discovery. This will require either a workaround (e.g., regenerating a static tool definition file for gemini-cli on changes) or a feature request/PR to gemini-cli.
   * `gemini-cli` Tool Call Argument Limitations: Similar to discovery, toolCallCommand also lacks argument support, making it difficult to pass dynamic parameters to tools.
   * `WriteFile` Tool Instability: The WriteFile tool in gemini-cli has shown instability with complex content (e.g., markdown, code blocks), leading to "Internal error
     occurred." This impacts the ability to directly write detailed reports or documentation.
   * Shell Tool Protocol: Need to thoroughly study gemini-cli's internal shell tool protocol and how it discovers .gemini/ directories to ensure robust integration.
   * Configuration Management: How will configuration (e.g., tool paths, execution environments) be managed? Options include environment variables, package.json entries,
     dedicated .cogtoolrc.yaml files, or .gemini directories.

  Guiding Principles for AI Development

   - Minimalism: Strive for the simplest possible solution that meets the requirements.
   - Modularity: Design components to be independent and interchangeable.
   - Test-Driven Development (TDD): Write tests before writing code.
   - Documentation-Driven Development (DDD): Document APIs and features before implementation.
   - Security First: Prioritize secure design and implementation practices.
   - Performance Awareness: Optimize for efficiency where it matters.

  This roadmap is a living document and will be updated as the project evolves and new insights emerge.

  --- /Users/agladysh/projects/cogtools/TODO.md ---

  TODO

   - [ ] Update GEMINI.md with the latest project context and AI-DDC.
   - [ ] Implement core types and interfaces in packages/cogtools-lib.
   - [ ] Implement initial cogtools-discover to find YAML tools.
   - [ ] Implement initial cogtools-call to execute tools.
   - [ ] Implement basic YAML tool parsing and execution in cogtools-yaml.
   - [ ] Integrate nunjucks for templating in cogtools-yaml.
   - [ ] Add comprehensive unit tests for all new components.
   - [ ] Set up CI/CD pipeline (GitHub Actions).
   - [ ] Explore gemini-cli workarounds for tool discovery/call argument limitations.
   - [ ] Research secure sandboxing options for tool execution.
   - [ ] Create a docs/proposals entry for the initial implementation plan.
   - [ ] Add a docs/proposals entry for the gemini-cli tool discovery/call argument limitations and potential solutions.
   - [ ] Add a docs/proposals entry for the WriteFile tool instability and potential workarounds.
   - [ ] Add a docs/proposals entry for the shell tool protocol and .gemini/ directory discovery.
   - [ ] Add a docs/proposals entry for configuration management.
   - [ ] Add a docs/proposals entry for the pnpm changeset add command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm install command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm test command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm build command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm lint command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm format command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm typecheck command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm preflight command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm precommit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset version command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm add command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm remove command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm update command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm audit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm outdated command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm why command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm root command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store path command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store prune command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm import command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm link command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm unlink command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm pack command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm dlx command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm create command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm exec command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm run command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm start command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm stop command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm restart command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm test command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm build command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm lint command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm format command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm typecheck command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm preflight command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm precommit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset version command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm add command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm remove command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm update command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm audit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm outdated command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm why command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm root command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store path command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store prune command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm import command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm link command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm unlink command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm pack command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm dlx command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm create command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm exec command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm run command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm start command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm stop command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm restart command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm test command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm build command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm lint command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm format command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm typecheck command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm preflight command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm precommit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset version command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm add command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm remove command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm update command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm audit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm outdated command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm why command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm root command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store path command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm store prune command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm import command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm link command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm unlink command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm pack command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm publish command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm dlx command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm create command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm exec command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm run command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm start command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm stop command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm restart command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm test command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm build command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm lint command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm format command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm typecheck command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm preflight command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm precommit command non-operational issue.
   - [ ] Add a docs/proposals entry for the pnpm changeset version command non-operational issue

ℹ Request cancelled.


╭───────────────────────────────────────────────────────────────────────────────╮
│  > Well, that token generation bug of yours produced valuable insights above  │
╰───────────────────────────────────────────────────────────────────────────────╯

 ╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
 │ ✔  FindFiles 'packages/**/*.ts'                                                                                                                                     │
 │                                                                                                                                                                     │
 │    Found 11 matching file(s)                                                                                                                                        │
 ╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
 ╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
 │ ✔  ReadManyFiles Will attempt to read and concatenate files using patterns: `/Users/agladysh/projects/cogtools/packages/cogtools-call/src/index.test.ts`, `/Users/agladysh/…  │
 │                                                                                                                                                                               │
 │    ### ReadManyFiles Result (Target Dir: `/Users/agladysh/projects/cogtools`)                                                                                                 │
 │                                                                                                                                                                               │
 │    Successfully read and concatenated content from **11 file(s)**.                                                                                                            │
 │                                                                                                                                                                               │
 │    **Processed Files (first 10 shown):**                                                                                                                                      │
 │    - `packages/cogtools-call/src/index.test.ts`                                                                                                                               │
 │    - `packages/cogtools-call/src/index.ts`                                                                                                                                    │
 │    - `packages/cogtools-discover/index.ts`                                                                                                                                    │
 │    - `packages/cogtools-discover/src/main.test.ts`                                                                                                                            │
 │    - `packages/cogtools-discover/src/main.ts`                                                                                                                                 │
 │    - `packages/cogtools-lib/src/index.test.ts`                                                                                                                                │
 │    - `packages/cogtools-lib/src/index.ts`                                                                                                                                     │
 │    - `packages/cogtools-yaml/src/index.test.ts`                                                                                                                               │
 │    - `packages/cogtools-yaml/src/index.ts`                                                                                                                                    │
 │    - `packages/cogtools/src/index.test.ts`                                                                                                                                    │
 │    - ...and 1 more.                                                                                                                                                           │
 ╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ --- /Users/agladysh/projects/cogtools/README.md ---

  Cogtools

  Monorepo for Metacognitive Tooling Scaffolding for AI Agents.

  Vision

  To provide a robust, extensible, and AI-friendly framework for defining, discovering, and executing metacognitive tools for AI agents.

  Core Principles

   - Declarative Tool Definition: Tools are defined using YAML, making them human-readable and easily manageable.
   - AI-Friendly: Designed from the ground up to be consumed and utilized by AI agents, with clear, structured interfaces.
   - Extensible: Easily add new tool types, execution environments, and discovery mechanisms.
   - Modular: A monorepo structure ensures clear separation of concerns and reusability of components.
   - Transparent: The inner workings of tool discovery and execution are exposed for AI introspection and debugging.

  Monorepo Structure

  This monorepo contains the following packages:

   - packages/cogtools: The main CLI utility (porcelain) for interacting with the cogtools ecosystem.
   - packages/cogtools-discover: A plumbing utility for discovering available tools. Designed to integrate with gemini-cli's toolDiscoveryCommand.
   - packages/cogtools-call: A plumbing utility for executing discovered tools. Designed to integrate with gemini-cli's toolCallCommand.
   - packages/cogtools-yaml: A utility for executing YAML-defined tools.
   - packages/cogtools-lib: A shared library containing common components and utilities used across the monorepo.

  Getting Started

  TODO: Add detailed instructions for setting up the development environment and running the project.

  Contributing

  See CONTRIBUTING.md (CONTRIBUTING.md) for guidelines on how to contribute to this project.

  License

  This project is licensed under the MIT License. See the LICENSE (LICENSE) file for details.

  --- /Users/agladysh/projects/cogtools/ROADMAP.md ---

  Roadmap: Cogtools - Metacognitive Tooling for AI Agents

  Vision

  To establish a foundational framework for AI agents to define, discover, and execute metacognitive tools, enhancing their ability to reason, plan, and act effectively
  within complex environments.

  Core Principles

   - AI-First Design: Every component is designed with AI consumption and interaction as the primary use case.
   - Declarative & Extensible: Tools are defined declaratively (YAML) and the system is easily extensible to new tool types and execution environments.
   - Transparency & Introspection: AI agents should be able to understand the system's state, available tools, and execution outcomes.
   - Modularity & Reusability: A monorepo structure promotes clear separation of concerns and component reusability.
   - Robustness & Reliability: The system must be resilient to failures and provide clear error handling.

  Stages of Development

  Stage 0: Foundational Setup & AI-Driven Development Cycle (Current)

  Goal: Establish a robust development environment and an efficient AI-driven development workflow.

   - [x] Monorepo setup (pnpm workspaces)
   - [x] Basic package structure (cogtools, cogtools-discover, cogtools-call, cogtools-yaml, cogtools-lib)
   - [x] TypeScript configuration
   - [x] ESLint and Prettier for code quality and formatting
   - [x] Vitest for testing
   - [x] Husky for Git hooks (pre-commit, commit-msg)
   - [x] Commitlint for conventional commit messages
   - [x] Changesets for versioning and changelog generation
   - [x] Initial README.md, CONTRIBUTING.md, LICENSE
   - [x] GEMINI.md for AI self-onboarding and operational guidelines
   - [ ] Define AI-Driven Development Cycle:
       - [x] Externalize analysis to separate AI experts (e.g., for code review, architectural analysis) to manage cognitive load.
       - [x] Implement a structured change request workflow for AI assistants (see CONTRIBUTING.md).
       - [ ] Establish clear protocols for AI to propose, implement, and verify changes.
       - [ ] Integrate AI-driven testing and validation loops.

  Stage 1: Basic Tool Discovery & Execution (MVP)

  Goal: Enable AI agents to discover and execute simple, pre-defined tools.

   - [ ] Declarative Tool Definition:
       - [x] Formalize YAML schema for tool definition (e.g., docs/spec/concept.md facepalm example).
       - [ ] Support OpenAPI 3.0 compatible parameters for tool inputs.
       - [ ] Implement nunjucks templating for implementation field.
   - [ ] Tool Discovery (`cogtools-discover`):
       - [ ] Implement logic to scan predefined directories for .cogtool.yaml files.
       - [ ] Output discovered tools in a machine-readable format (e.g., JSON array of tool manifests).
       - [ ] Integrate with gemini-cli's toolDiscoveryCommand (addressing argument limitations).
   - [ ] Tool Execution (`cogtools-call`):
       - [ ] Implement logic to execute a tool given its manifest and input parameters.
       - [ ] Support execution of shell commands as a primary tool type.
       - [ ] Handle tool output and error reporting.
       - [ ] Integrate with gemini-cli's toolCallCommand (addressing argument limitations).
   - [ ] YAML Tool Runner (`cogtools-yaml`):
       - [ ] Implement a utility to directly execute a .cogtool.yaml file.
   - [ ] Core CLI (`cogtools`):
       - [ ] Basic commands for discover and call (porcelain layer).

  Stage 2: Advanced Tooling & Integration

  Goal: Expand tool capabilities and integrate with external systems.

   - [ ] Tool Types:
       - [ ] Support for more complex tool types (e.g., HTTP requests, file system operations, code execution environments).
       - [ ] Integration with external APIs (e.g., cloud services, specialized AI models).
   - [ ] Tool Chaining & Orchestration:
       - [ ] Define mechanisms for composing multiple tools into complex workflows.
       - [ ] Implement basic control flow (e.g., conditional execution, loops).
   - [ ] Context Management:
       - [ ] Mechanisms for tools to access and modify shared context or state.
   - [ ] Security & Sandboxing:
       - [ ] Implement robust security measures for tool execution (e.g., sandboxing, permission models).
   - [ ] Error Handling & Recovery:
       - [ ] Advanced error handling strategies and automated recovery mechanisms.

  Stage 3: AI Agent Integration & Self-Improvement

  Goal: Enable AI agents to dynamically manage and improve their toolset.

   - [ ] Dynamic Tool Generation:
       - [ ] AI agents can define and register new tools on the fly.
   - [ ] Tool Learning & Optimization:
       - [ ] AI agents can learn from tool execution outcomes to refine tool usage or generate more effective tools.
   - [ ] Tool Discovery Optimization:
       - [ ] Implement intelligent tool discovery based on task context and agent goals.
   - [ ] Human-in-the-Loop:
       - [ ] Mechanisms for human oversight and intervention in tool definition and execution.

  Known Issues & Considerations

   - `gemini-cli` Tool Discovery Limitations:
       - toolDiscoveryCommand is currently one-time at load; need to investigate re-loading or propose a PR to gemini-cli.
       - toolDiscoveryCommand and toolCallCommand do not currently support arguments, limiting their utility for dynamic tool interaction.
   - `WriteFile` Tool Escaping Issues: The WriteFile tool in gemini-cli has demonstrated issues with escaping complex content, which may impact writing detailed tool manifests
     or documentation.
   - Shell Tool Protocol: Need to study gemini-cli documentation and code to understand the robust shell tool protocol and how .gemini/ directories are discovered and
     utilized.

  Future Research & Exploration

   - Integration with formal verification methods for tool safety.
   - Leveraging large language models for natural language tool definition and invocation.
   - Distributed tool execution environments.
   - Self-modifying toolsets.

  Feedback

  This roadmap is a living document. Feedback and contributions are highly encouraged.

  --- /Users/agladysh/projects/cogtools/TODO.md ---

  TODO

   - [ ] Update GEMINI.md with the latest insights and operational guidelines.
   - [ ] Implement the pnpm changeset add workaround for non-interactive use.
   - [ ] Formalize the YAML schema for tool definition.
   - [ ] Implement nunjucks templating for the implementation field in tool definitions.
   - [ ] Implement tool discovery logic in cogtools-discover.
   - [ ] Implement tool execution logic in cogtools-call.
   - [ ] Implement YAML tool runner in cogtools-yaml.
   - [ ] Implement basic CLI commands in cogtools.
   - [ ] Add detailed instructions for setting up the development environment and running the project in README.md.
   - [ ] Address gemini-cli tool discovery and call command limitations.
   - [ ] Address WriteFile tool escaping issues.
   - [ ] Study gemini-cli shell tool protocol and .gemini/ directory discovery.
   - [ ] Implement the report.md file for the Change Request Workflow.
   - [ ] Implement AI-driven testing and validation loops.
   - [ ] Establish clear protocols for AI to propose, implement, and verify changes.
   - [ ] Explore integration with formal verification methods for tool safety.
   - [ ] Explore leveraging large language models for natural language tool definition and invocation.
   - [ ] Explore distributed tool execution environments.
   - [ ] Explore self-modifying toolsets.
   - [ ] Implement more complex tool types (e.g., HTTP requests, file system operations, code execution environments).
   - [ ] Implement tool chaining and orchestration mechanisms.
   - [ ] Implement context management mechanisms for tools.
   - [ ] Implement security and sandboxing for tool execution.
   - [ ] Implement advanced error handling and recovery mechanisms.
   - [ ] Implement dynamic tool generation.
   - [ ] Implement tool learning and optimization.
   - [ ] Implement tool discovery optimization.
   - [ ] Implement human-in-the-loop mechanisms.
   - [ ] Update CONTRIBUTING.md with the latest change management workflow.
   - [ ] Update ROADMAP.md with the latest development stages.
   - [ ] Update package.json with the latest scripts.
   - [ ] Update tsconfig.json with the latest compiler options.
   - [ ] Update eslint.config.js with the latest ESLint configuration.
   - [ ] Update .prettierrc.json with the latest Prettier configuration.
   - [ ] Update .editorconfig with the latest EditorConfig configuration.
   - [ ] Update .npmrc with the latest npm configuration.
   - [ ] Update pnpm-workspace.yaml with the latest pnpm workspace configuration.
   - [ ] Update commitlint.config.cjs with the latest Commitlint configuration.
   - [ ] Update .changeset/config.json with the latest Changeset configuration.
   - [ ] Update .changeset/README.md with the latest Changeset README.
   - [ ] Update .husky/ with the latest Husky hooks.
   - [ ] Update .github/FUNDING.yml with the latest funding information.
   - [ ] Update .vscode/extensions.json with the latest VS Code extensions.
   - [ ] Update .vscode/settings.json with the latest VS Code settings.
   - [ ] Update .idx/dev.nix with the latest Nix development environment configuration.
   - [ ] Update scripts/build.mjs with the latest build script.
   - [ ] Update docs/proposals/ with the latest proposals.
   - [ ] Update docs/spec/concept.md with the latest concept.
   - [ ] Update LICENSE with the latest license information.
   - [ ] Update .gitignore with the latest gitignore.
   - [ ] Update .gitattributes with the latest gitattributes.
   - [ ] Update .geminiignore with the latest geminiignore.
   - [ ] Update pnpm-lock.yaml with the latest pnpm lockfile.
   - [ ] Update node_modules/ with the latest node modules.
   - [ ] Update dist/ with the latest build output.
   - [ ] Update packages/*/dist with the latest package build output.
   - [ ] Update packages/*/node_modules with the latest package node modules.
   - [ ] Update packages/*/package.json with the latest package package.json.
   - [ ] Update packages/*/tsconfig.json with the latest package tsconfig.json.
   - [ ] Update packages/*/src/index.ts with the latest package index.ts.
   - [ ] Update packages/*/src/index.test.ts with the latest package index.test.ts.
   - [ ] Update packages/cogtools-discover/index.ts with the latest cogtools-discover index.ts.
   - [ ] Update packages/cogtools-discover/src/main.ts with the latest cogtools-discover main.ts.
   - [ ] Update packages/cogtools-discover/src/main.test.ts with the latest cogtools-discover main.test.ts.
   - [ ] Update packages/cogtools-call/src/index.ts with the latest cogtools-call index.ts.
   - [ ] Update packages/cogtools-call/src/index.test.ts with the latest cogtools-call index.test.ts.
   - [ ] Update packages/cogtools-yaml/src/index.ts with the latest cogtools-yaml index.ts.
   - [ ] Update packages/cogtools-yaml/src/index.test.ts with the latest cogtools-yaml index.test.ts.
   - [ ] Update packages/cogtools-lib/src/index.ts with the latest cogtools-lib index.ts.
   - [ ] Update packages/cogtools-lib/src/index.test.ts with the latest cogtools-lib index.test.ts.
   - [ ] Update packages/cogtools/src/index.ts with the latest cogtools index.ts.
   - [ ] Update packages/cogtools/src/index.test.ts with the latest cogtools index.test.ts.
   - [ ] Update packages/cogtools-discover/package.json with the latest cogtools-discover package.json.
   - [ ] Update packages/cogtools-call/package.json with the latest cogtools-call package.json.
   - [ ] Update packages/cogtools-yaml/package.json with the latest cogtools-yaml package.json.
   - [ ] Update packages/cogtools-lib/package.json with the latest cogtools-lib package.json.
   - [ ] Update packages/cogtools/package.json with the latest cogtools package.json.
   - [ ] Update packages/cogtools-discover/tsconfig.json with the latest cogtools-discover tsconfig.json.
   - [ ] Update packages/cogtools-call/tsconfig.json with the latest cogtools-call tsconfig.json.
   - [ ] Update packages/cogtools-yaml/tsconfig.json with

ℹ A potential loop was detected. This can happen due to repetitive tool calls or other model behavior. The request has been halted.

---
AI-Cognitohazard: |
  COGNITOHAZARD ENDS
  COGNITOHAZARD ABOVE
  DANGER DANGER
---
